## JVM
Java虚拟机

> Everyday study JVM ...emm  :stuck_out_tongue_winking_eye:


###第三章 垃圾回收器与内存分配策略
>哪些内存需要回收?
什么时候回收?
如何回收?

使用的算法
第一种:引用计数算法:
判断对象是否存活,给对象添加一个引用计数器,每当有一个地方引用他,计数器+1;当引用失效时-1;
任何时刻的计数器为0的对象就是不可能再被使用的.

引用计数算法
优点:**实现简单,判定效率高**
缺点:**无法解决互相循环引用的问题**

第二种:可达性分析算法:
可达性分析算法的基本思路就是通过一系列的成为"GC Roots"的对象作为起始点.
从此节点往下搜索,搜索所走过的路径成为引用链,
当一个对象到GC Roots没有任何引用链的时候,则证明此对象是不可用的.可回收的对象

>GC Roots对象包括哪几种?
1.虚拟机栈(栈帧终端本地变量表)中引用的对象;
2.方法区中类静态属性引用的对象
3.方法区中常量引用的对象
4.本地方法栈中JNI(一般说的Native方法)引用的对象.

上面两种算法都说到了**引用**

引用的四种类型:
1.强引用:代码中普遍存在的 如: Object obj = new Object();
这类的引用,只要强引用还存在,垃圾收集器永远不会回收掉被引用的对象

2.软引用:有用但是非必须的对象.对于软引用的关联对象,在系统要发生内存溢出之前,会把这些对象列入回收范围进行第二次回收.
如果这次回收还没有足够的内存,才会抛出内存异常. JDK1.2之后提供了SoftReference类来实现软引用.

3.弱引用:他的强度比软引用更弱,被弱引用关联的对象只能生存到下一次垃圾收集发生之前.
当垃圾收集器工作时,无论当前内存是否足够,都会回收掉只被弱引用关联的对象. JDK1.2之后提供了WaekReference类来实现软引用.

4.虚引用:也成为幽灵引用.最弱的一种引用关系

生存还是死亡?
即时可达性分析算法中的不可达对象,也并非是非死不可的.
这些不可达对象要经过两次标记过程:
如果对象在进行可达性分析后发现没有与GC Roots相连,那么会被进行第一次标记并进行筛选,筛选条件是对象是否有必要执行finalize()方法.
当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机条用过,那么虚拟机不对这些对象执行回收

回收方法区:
永久代的垃圾收集主要回收两部分内容,废弃的常量和无用的类. 回收废弃常量与回收Java堆中的对象非常类似. 
满足下面三个条件才会被回收;
1.该类所有的实例都已经被回收,也就是java堆中不存在该类的任何实例;
2.加载该类的ClassLoader已经被回收
3.该类对应的java.lang.Class对象没有在任何地方被引用.无法在任何地方通过反射访问该类的方法

###垃圾回收的算法:
1.标记-清除算法
首先标记所有需要回收的对象,在标记完成后统一回收所有被标记的对象.
缺点效率不高,并且回收的时候,标记清除后会产生大量的不连续的内存碎片.

空间碎片过多会导致,程序运行过程中需要分配较大对象时,无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作.

2.复制算法(解决效率问题)
复制算法可用内存按容量划分大小相等的两块,每次只使用其中一块,当这块内存用完,就将还存活着的对象复制到另外一块上面,然后再把已使用过的内存空间一次清理掉.
这个方法就可以不用考虑内存碎片等复杂问题,只要移动堆顶指针.按顺序分配内存即可,实现简单,运行高效.
缺点内存大小缩小为了原来的一半

Eden 和 Survivor 的分配比例是 8:1 .这样每次新生代可用内存空间为整个新生代容量的90%(80%+10%),
只有10%的内存会被浪费,当然,98%的对象可回收只是一般场景下的数据.没法保证每次回收只有不多于10%的对象存活.但是有``分配担保``策略解决

3.标记-整理算法
复制算法在对象存活率高的时候做的复制操作多,效率会变低.更关键不想浪费50%的空间,就要有分配担保,以应对被使用的内存中所有对象都100%存活的极端状态,
所以老年代一般不能直接选择这种算法.


4.分代收集法
根据对象的存活周期,把不同的内存划分为几块. 一般把java堆分为新生代和老年代,
这样就可以根据各个年代的特点,用最适当的收集算法.
新生代中,每次垃圾收集时都发现有大批对象死去,只有少量存活,那就选用复制算法.
只需要付出少量存活对象的复制成本就可以完成收集.而老年代中因为对象存活率高,
没有额外的空间对它进行分配担保,就必须使用'标记清理','标记整理'算法来回收

###HostSpot算法的实现
1.枚举根节点
从可达性分析中从GC Roots节点找引用链与这个操作为例,可作为GC Roots的节点主要
在全局性的引用(例如常量或者类静态属性) 与执行上下文(例如栈帧中的本地变量表)中
 
---------------
垃圾回收算法是方法论,垃圾收集器是具体实现

###垃圾收集器
>两个不同的垃圾收集器可以配合使用.

1.Serial收集器(串行收集器)
单线程,在回收的时候会 Stop The World,暂停虚拟机的所有操作
新生代收集器
简单高效

2.ParNew收集器(Serial收集器的多线程版本)
多线程,线程多的时候会比Serial的效果好,可以有效利用比较多的资源
新生代收集器
与性能无关

3.Parallel Scavenge收集器
新生代收集器 
使用复制算法, 并行多线程收集器

4.Serial Old收集器
Serial收集器的老年代版本,单线程收集器,采用标记整理算法

5.Parallel Old收集器
Parallel Scavenge收集器的老年版本,使用多线程和'标记整理'算法.
但是如果新生代选择了Parallel Scavenge. 那么老年代就只能用Serial Old

6.CMS收集器
CMS收集器是一种以获取最短停顿时间为目标的收集器,
基于标记-清除 算法实现.
工作步骤:
1.初始标记
2.并发标记
3.重新标记
4.并发清除
初始标记和重复标记仍需要Stop The World.

CMS是一款优秀的收集器:并发收集
缺点会产生浮动垃圾
用户的线程还在运行,需要给用户线程留下运行的内存空间g
参数:-XX:CMSInitialOccupyFraction 当老年代的空间使用超过这个值的时候就启动收集指令
值设置高, 减少回收次数,提高性能

当CMS Concurrent Mode Failure 发生了 启动Serial Old收集器.
-XX:+UseCMSCompactAtFullCollection(默认开启) 需要进行FullGC的时候开启内存碎片的整理,无法并发
-XX:CMSFullGCsBeforeCompaction (默认为0) ,设置多少次不压缩的FullGC后来一次压缩的 

G1垃圾回收:
-XX:+UseG1GC
特点:并行和并发,分代收集,空间整合
整体上看是标记整理算法,局部复制算法.
好处:没有空间碎片,有利于程序运行,可预测的停顿

初始标记:短暂,仅仅是标记GC Roots能直接关联到对象,速度很快, 产生一个短暂的全局停顿.都会又一次新生代的GC.
根区域扫描:扫描survival区可以直接到达老年代区域.
并发标记阶段:
